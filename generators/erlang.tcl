
gen::add_generator Erlang gen_erl::generate

namespace eval gen_erl {









proc foreach_init { item_id first second } {
	return ""
}

proc foreach_check { item_id first second } {
	return ""
}

proc foreach_current { item_id first second } {
	return ""
}

proc foreach_incr { item_id first second } {
	return ""
}

proc make_callbacks { } {
	set callbacks {}
	
	gen::put_callback callbacks assign			gen_erl::p.assign
	gen::put_callback callbacks compare			gen_erl::p.compare
	gen::put_callback callbacks compare2		gen_erl::p.compare2
	gen::put_callback callbacks while_start 	gen_erl::p.while_start
	gen::put_callback callbacks if_start		gen_erl::p.if_start
	gen::put_callback callbacks elseif_start	gen_erl::p.elseif_start
	gen::put_callback callbacks if_end			gen_erl::p.if_end
	gen::put_callback callbacks else_start		gen_erl::p.else_start
	gen::put_callback callbacks pass			gen_erl::p.pass
	gen::put_callback callbacks continue		gen_erl::p.continue
	gen::put_callback callbacks return_none		gen_erl::p.return_none
	gen::put_callback callbacks block_close		gen_erl::p.block_close
	gen::put_callback callbacks comment			gen_erl::p.comment
	gen::put_callback callbacks bad_case		gen_erl::p.bad_case
	gen::put_callback callbacks for_init		gen_erl::foreach_init
	gen::put_callback callbacks for_check		gen_erl::foreach_check
	gen::put_callback callbacks for_current		gen_erl::foreach_current
	gen::put_callback callbacks for_incr		gen_erl::foreach_incr
	gen::put_callback callbacks body			gen_erl::generate_body
	gen::put_callback callbacks signature		gen_erl::extract_signature
	gen::put_callback callbacks and				gen_erl::p.and
	gen::put_callback callbacks or				gen_erl::p.or
	gen::put_callback callbacks not				gen_erl::p.not
	gen::put_callback callbacks break			"break"
	gen::put_callback callbacks declare			gen_erl::p.declare
	gen::put_callback callbacks for_declare		gen_erl::for_declare
	
	gen::put_callback callbacks line_end		","
	gen::put_callback callbacks enforce_nogoto	gen_erl::enforce_nogoto
	gen::put_callback callbacks inspect_tree	gen_erl::inspect_tree
	
	return $callbacks
}

proc p.declare { type name value } {
	return ""
}

proc generate_body { gdb diagram_id start_item node_list sorted incoming } {
	set callbacks [ make_callbacks ]
	return [ cbody::generate_body $gdb $diagram_id $start_item $node_list \
		$sorted $incoming $callbacks ]
}

proc p.and { left right } {
	return "($left) andalso ($right)"
}

proc p.or { left right } {
	return "($left) orelse ($right)"
}

proc p.not { operand } {
	return "not ($operand)"
}

proc p.assign { variable value } {
	return "$variable = $value"
}

proc p.compare { variable value } {
	return "$variable =:= $value"
}

proc p.compare2 { variable value } {
	return "$variable =:= $value"
}


proc p.while_start { } {
	return ""
}

proc p.if_start { } {
	return "if "
}

proc p.elseif_start { } {
	return ""
}

proc p.if_end { } {
	return " -> "
}

proc p.else_start { } {
	return "; true ->"
}
proc p.pass { } {
	return "\[\]"
}

proc p.continue { } {
	return ""
}

proc p.return_none { } {
	return ""
}

proc p.block_close { output depth } {
	upvar 1 $output result
	set line [ gen::make_indent $depth ]
	append line "end"
	lappend result $line
}

proc p.comment { line } {
	return "% $line"
}

proc p.bad_case { switch_var } {
	return "throw\(\"Unexpected switch value\"\)"
}

proc for_declare { item_id first second } {
	return ""
}

proc generate { db gdb filename } {
	set callbacks [ make_callbacks ]

	gen::fix_graph $gdb $callbacks 0
	unpack [ gen::scan_file_description $db { header footer } ] header footer

	set use_nogoto 1
	set functions [ gen::generate_functions $db $gdb $callbacks $use_nogoto ]

	if { [ graph::errors_occured ] } { return }


	set hfile [ replace_extension $filename "erl" ]
	set module [ file tail [ string map {".drn" ""} $filename ] ]
	set f [ open $hfile w ]
	catch {
		p.print_to_file $f $functions $header $footer $module
	} error_message

	catch { close $f }
	if { $error_message != "" } {
		error $error_message
	}
}

proc build_declaration { name signature } {
	unpack $signature type access parameters returns
	set result "$name\("
	set params {}
	foreach parameter $parameters {
		lappend params [ lindex $parameter 0 ]
	}
	set params_list [ join $params ", " ]
	append result $params_list
	append result "\) ->"
	return $result
}

proc p.print_to_file { fhandle functions header footer module } {

	set version [ version_string ]
	puts $fhandle \
	    "% Autogenerated with DRAKON Editor $version"

	puts $fhandle ""
	puts $fhandle "-module\($module\)."

	set exported {}
	foreach function $functions {
		unpack $function diagram_id name signature body
		set access [ lindex $signature 1 ]
		if { $access == "public" } {
			set arguments [ lindex $signature 2 ]
			set count [ llength $arguments ]
			lappend exported "$name/$count"
		}
	}
	
	if { [ llength $exported ] > 0 } {
		set exp_list [ join $exported ", " ]
		puts $fhandle "-export\(\[$exp_list\]\)."
	}
	
	if { $header != "" } {
		puts $fhandle $header
	}

	foreach function $functions {
		unpack $function diagram_id name signature body
		set type [ lindex $signature 0 ]
		if { $type != "comment" } {
			puts $fhandle ""
			set declaration [ build_declaration $name $signature ]
			puts $fhandle $declaration
			set lines [ gen::indent $body 1 ]
			puts $fhandle $lines
			puts $fhandle "."
		}
	}
	puts $fhandle ""
	puts $fhandle $footer
}



proc extract_signature { text name } {
	set lines [ gen::separate_from_comments $text ]
	set count [ llength $lines ]
	if { $count == 0 } {
		set access "internal"
		set type "function"
		set parameters {}
	} else {
		set first_line [ lindex $lines 0 ]
		set first [ lindex $first_line 0 ]
		if { $first == "#comment" } {
			set access "internal"
			set type "comment"
			set parameters {}
		} else {
			if { $first == "public" } {
				set i 1
				set access "public"
			} else {
				set i 0
				set access "internal"
			}
			set type "function"
			set parameters {}
			while { $i < $count } {
				set current [ lindex $lines $i ]
				lappend parameters $current
				
				incr i
			}
		}
	}

	return [ list {} [ gen::create_signature $type $access $parameters "" ] ]
}


proc enforce_nogoto { name } {
	throw "Could not generate code for function '%name'.\nTry splitting it into smaller parts."
}

proc inspect_tree { node name } {
	set length [ llength $node ]
	
	for { set i 1 } { $i < $length } { incr i } {
		set current [ lindex $node $i ]
		if { [ string is integer $current ] } {
		
		} elseif { $current == "break" || $current == "continue" ||
			[ lindex $current 0 ] == "loop" } {
			
			error "Function '$name' contains a loop.\nErlang does not support loops."
		} elseif { [ lindex $current 0 ] == "if" } {		
			set then_node [ lindex $current 3 ]
			set else_node [ lindex $current 2 ]
			inspect_tree $then_node $name
			inspect_tree $else_node $name
		}
	}
}


}

