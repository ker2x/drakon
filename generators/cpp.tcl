gen::add_generator "C++" gen_cpp::generate
gen::add_generator "C" gen_cpp::generate_c

namespace eval gen_cpp {

# Autogenerated with DRAKON Editor 1.11

proc check { keywords args } {
    #item 6290001
    set _col629 $args
    set _len629 [ llength $_col629 ]
    set _ind629 0
    while { 1 } {
        #item 6290002
        if {$_ind629 < $_len629} {
            #item 6290004
            set arg [ lindex $_col629 $_ind629 ]
            #item 622
            upvar 1 $arg keyword
            #item 623
            if {[ contains $keywords $arg ]} {
                #item 625
                set keyword 1
            } else {
                #item 624
                set keyword 0
            }
            #item 6290003
            incr _ind629
            continue
        } else {
            break
        }
    }
}

proc classify_keywords { keywords name } {
    #item 687
    set errors {}
    check $keywords abstract const inline
    #item 633
    set access [ find_keywords $keywords { private public protected } ]
    #item 6480000
    set _sw6480000_ [ llength $access ]
    #item 6480001
    if {($_sw6480000_ == 0) || ($_sw6480000_ == 1)} {
        
    } else {
        #item 638
        lappend errors "$name: inconsistent access: $access"
    }
    #item 640
    set dispatch [ find_keywords $keywords { virtual static } ]
    #item 6610000
    set _sw6610000_ [ llength $dispatch ]
    #item 6610001
    if {$_sw6610000_ == 0} {
        #item 660
        set dispatch "normal"
    } else {
        #item 6610002
        if {$_sw6610000_ == 1} {
            
        } else {
            #item 653
            lappend errors "$name: inconsistent dispatch: $dispatch"
        }
    }
    #item 671
    set subtype [ find_keywords $keywords \
    	{ function method ctr dtr signal slot} ]
    #item 6720000
    set _sw6720000_ [ llength $subtype ]
    #item 6720001
    if {$_sw6720000_ == 0} {
        #item 670
        set subtype "function"
    } else {
        #item 6720002
        if {$_sw6720000_ == 1} {
            
        } else {
            #item 663
            lappend errors "$name: inconsistent procedure type: $subtype"
        }
    }
    #item 1212
    if {($inline) && ($abstract)} {
        #item 1216
        lappend errors \
        "$name: both inline and abstract is not allowed"
    } else {
        
    }
    #item 1217
    if {$abstract} {
        #item 1218
        set dispatch "virtual"
    } else {
        
    }
    #item 6740001
    if {$subtype == "function"} {
        #item 855
        if {($access == "protected") || ($access == "private")} {
            #item 859
            lappend errors \
            "$name: a function cannot be $access"
        } else {
            
        }
        #item 695
        if {$access == "public"} {
            #item 706
            if {$dispatch == "static"} {
                #item 699
                lappend errors \
                "$name: a function cannot be both public and static"
            } else {
                
            }
        } else {
            #item 713
            set access "static"
        }
        #item 703
        if {($dispatch == "normal") || ($dispatch == "static")} {
            
        } else {
            #item 704
            lappend errors \
            "$name: wrong dispatch: $dispatch"
        }
        #item 716
        if {$abstract} {
            #item 717
            lappend errors \
            "$name: a function cannot be abstract"
        } else {
            
        }
        #item 723
        if {$const} {
            #item 724
            lappend errors \
            "$name: a function cannot be abstract"
        } else {
            
        }
    } else {
        #item 6740002
        if {$subtype == "method"} {
            
        } else {
            #item 6740003
            if {$subtype == "ctr"} {
                #item 730
                if {$dispatch == "normal"} {
                    
                } else {
                    #item 731
                    lappend errors \
                    "$name: constructor cannot be $dispatch"
                }
                #item 734
                if {$const} {
                    #item 735
                    lappend errors \
                    "$name: constructor cannot be const"
                } else {
                    
                }
                #item 738
                if {$abstract} {
                    #item 739
                    lappend errors \
                    "$name: constructor cannot be abstract"
                } else {
                    
                }
            } else {
                #item 6740004
                if {$subtype == "dtr"} {
                    #item 7530001
                    if {$dispatch == "normal"} {
                        #item 759
                        set dispatch "virtual"
                    } else {
                        #item 7530002
                        if {$dispatch == "virtual"} {
                            
                        } else {
                            #item 746
                            lappend errors \
                            "$name: destructor cannot be $dispatch"
                        }
                    }
                    #item 760
                    if {$const} {
                        #item 761
                        lappend errors \
                        "$name: destructor cannot be const"
                    } else {
                        
                    }
                    #item 764
                    if {$abstract} {
                        #item 765
                        lappend errors \
                        "$name: destructor cannot be abstract"
                    } else {
                        
                    }
                    #item 7710001
                    if {$access == ""} {
                        #item 776
                        set access "public"
                    } else {
                        #item 7710002
                        if {$access == "public"} {
                            
                        } else {
                            #item 768
                            lappend errors \
                            "$name: destructor cannot be $access"
                        }
                    }
                } else {
                    #item 6740005
                    if {$subtype == "signal"} {
                        #item 784
                        if {$dispatch == "normal"} {
                            
                        } else {
                            #item 788
                            lappend errors \
                            "$name: a signal cannot be virtual or static"
                        }
                        #item 1230
                        if {$const} {
                            #item 1231
                            lappend errors \
                            "$name: signal cannot be const"
                        } else {
                            
                        }
                        #item 1234
                        if {$abstract} {
                            #item 1235
                            lappend errors \
                            "$name: signal cannot be abstract"
                        } else {
                            
                        }
                        #item 1244
                        set access "public"
                        set inline 0
                    } else {
                        #item 6740006
                        if {($subtype == "slot") && ($dispatch == "static")} {
                            #item 1224
                            lappend errors \
                            "$name: a slot cannot be static"
                        } else {
                            
                        }
                    }
                }
            }
        }
    }
    #item 749
    if {$access == ""} {
        #item 750
        set access "private"
    } else {
        
    }
    #item 778
    array set props {}
    #item 779
    set props(access) $access
    set props(dispatch) $dispatch
    set props(type) $subtype
    set props(abstract) $abstract
    set props(const) $const
    set props(inline) $inline
    #item 780
    set proplist [ array get props ]
    set error_message [ join $errors "\n" ]
    #item 781
    return [ list $error_message $proplist ]
}

proc commentator { text } {
    #item 143
    return "// $text"
}

proc extract_class_name { section } {
    #item 1202
    set section [ string map { "\{" " " } $section ]
    #item 944
    set lines [ split $section "\n" ]
    #item 9450001
    set _col945 $lines
    set _len945 [ llength $_col945 ]
    set _ind945 0
    while { 1 } {
        #item 9450002
        if {$_ind945 < $_len945} {
            #item 9450004
            set line [ lindex $_col945 $_ind945 ]
            #item 946
            if {[ llength $line ] >= 2} {
                #item 947
                set first [ lindex $line 0 ]
                set second [ lindex $line 1 ]
                #item 948
                if {($first == "class") || ($first == "struct")} {
                    #item 956
                    return [ string map { ":" "" } $second ]
                } else {
                    #item 9450003
                    incr _ind945
                    continue
                }
            } else {
                #item 9450003
                incr _ind945
                continue
            }
        } else {
            #item 955
            return ""
        }
    }
}

proc extract_copying { section } {
    #item 879
    set lines [ split $section "\n" ]
    #item 8780001
    set _col878 $lines
    set _len878 [ llength $_col878 ]
    set _ind878 0
    while { 1 } {
        #item 8780002
        if {$_ind878 < $_len878} {
            #item 8780004
            set line [ lindex $_col878 $_ind878 ]
            #item 880
            set value [ get_property $line "copying" ]
            #item 881
            if {$value == ""} {
                #item 8780003
                incr _ind878
                continue
            } else {
                #item 887
                if {$value == "yes"} {
                    #item 888
                    return 1
                } else {
                    #item 886
                    return 0
                }
            }
        } else {
            #item 885
            return 0
        }
    }
}

proc extract_return_type { text } {
    #item 491
    set skip [ string length "returns " ]
    set raw [ string range $text $skip end ]
    return [ string trim $raw ]
}

proc extract_signature { text name } {
    array set props { access static abstract 0
     inline 0 dispatch normal const 0 type function }
    set error_message ""
    set parameters {}
    set type "function"
    set returns ""
    #item 15
    set lines [ gen::separate_from_comments $text ]
    
    set _next_item_ 17
    while { 1 } {
        if {$_next_item_ == 17} {
            if {[ llength $lines ] == 0} {
                #item 833
                set returns "void"
                set _next_item_ 846
            } else {
                #item 16
                set first_line [ lindex $lines 0 ]
                set first [ lindex $first_line 0 ]
                set _next_item_ 589
            }
        }
    
        if {$_next_item_ == 589} {
            if {$first == "#comment"} {
                #item 42
                set type comment
                set returns ""
                set _next_item_ 846
            } else {
                #item 595
                set keywords { 
                	public private protected
                	virtual static
                	inline abstract const
                	method function ctr dtr 
                	signal slot }
                #item 596
                set found_keywords [ find_keywords $first $keywords ]
                set _next_item_ 594
            }
        }
    
        if {$_next_item_ == 594} {
            if {[ llength $found_keywords ] == 0} {
                #item 598
                set start_index 0
                set _next_item_ 34
            } else {
                #item 597
                set start_index 1
                #item 600
                set alien_keywords [ find_not_belonging $first $keywords ]
                set _next_item_ 601
            }
        }
    
        if {$_next_item_ == 601} {
            if {[ llength $alien_keywords ] == 0} {
                #item 790
                unpack [ classify_keywords $found_keywords $name ] \
                	error_message prop_list
                set _next_item_ 791
            } else {
                #item 602
                set error_message \
                    "$name: Unexpected keywords: $alien_keywords"
                set _next_item_ 846
            }
        }
    
        if {$_next_item_ == 791} {
            if {$error_message == ""} {
                #item 792
                array unset props
                array set props $prop_list
                set type $props(type)
                set _next_item_ 34
            } else {
                set _next_item_ 846
            }
        }
    
        if {$_next_item_ == 34} {
            set count [ llength $lines ]
            set last [ expr { $count - 1 } ]
            #item 370001
            set i $start_index
            set _next_item_ 370002
        }
    
        if {$_next_item_ == 370002} {
            if {$i < $count} {
                #item 36
                set current [ lindex $lines $i ]
                set stripped [ lindex $current 0 ]
                set _next_item_ 46
            } else {
                set _next_item_ 834
            }
        }
    
        if {$_next_item_ == 46} {
            if {[ string match "returns *" $stripped ]} {
                set _next_item_ 47
            } else {
                #item 45
                lappend parameters $current
                #item 370003
                incr i
                set _next_item_ 370002
                continue
            }
        }
    
        if {$_next_item_ == 47} {
            if {$i == $last} {
                #item 50
                set returns [ extract_return_type $stripped ]
                set _next_item_ 834
            } else {
                #item 52
                set error_message \
                "$name: 'returns' can only be the last line."
                set _next_item_ 834
            }
        }
    
        if {$_next_item_ == 834} {
            if {($type == "ctr") || ($type == "dtr")} {
                set _next_item_ 838
            } else {
                set _next_item_ 842
            }
        }
    
        if {$_next_item_ == 838} {
            if {$returns == ""} {
                set _next_item_ 846
            } else {
                #item 839
                set error_message \
                "$name: constructors and destructors must not have return type"
                set _next_item_ 846
            }
        }
    
        if {$_next_item_ == 842} {
            if {$returns == ""} {
                #item 845
                set returns "void"
                set _next_item_ 846
            } else {
                set _next_item_ 846
            }
        }
    
        if {$_next_item_ == 846} {
            if {($type == "dtr") && ([ llength $parameters ] > 0)} {
                #item 850
                set error_message \
                "$name: destructor cannot have parameters"
            } else {
                
            }
    
        #item 793
            set prop_list [ array get props ]
            #item 38
            return [ list $error_message \
            [ gen::create_signature $type $prop_list $parameters $returns ] ]
        }
    
    }
}

proc filter_functions { functions inline access } {
    #item 1082
    set result {}
    #item 10810001
    set _col1081 $functions
    set _len1081 [ llength $_col1081 ]
    set _ind1081 0
    while { 1 } {
        #item 10810002
        if {$_ind1081 < $_len1081} {
            #item 10810004
            set function [ lindex $_col1081 $_ind1081 ]
            #item 1085
            unpack $function diagram_id name signature body
            unpack $signature type prop_list parameters returns
            array set props $prop_list
            #item 1086
            if {($props(inline) == $inline) && ($props(access) == $access)} {
                #item 1088
                lappend result $function
            } else {
                
            }
            #item 10810003
            incr _ind1081
            continue
        } else {
            break
        }
    }
    #item 1083
    return $result
}

proc filter_methods { functions access } {
    #item 1097
    set result {}
    #item 10960001
    set _col1096 $functions
    set _len1096 [ llength $_col1096 ]
    set _ind1096 0
    while { 1 } {
        #item 10960002
        if {$_ind1096 < $_len1096} {
            #item 10960004
            set function [ lindex $_col1096 $_ind1096 ]
            #item 1100
            unpack $function diagram_id name signature body
            unpack $signature type prop_list parameters returns
            array set props $prop_list
            #item 1102
            if {$props(access) == $access} {
                #item 1103
                lappend result $function
            } else {
                
            }
            #item 10960003
            incr _ind1096
            continue
        } else {
            break
        }
    }
    #item 1098
    return $result
}

proc find_keywords { list keywords } {
    #item 804
    set result {}
    #item 8030001
    set _col803 $keywords
    set _len803 [ llength $_col803 ]
    set _ind803 0
    while { 1 } {
        #item 8030002
        if {$_ind803 < $_len803} {
            #item 8030004
            set keyword [ lindex $_col803 $_ind803 ]
            #item 807
            if {[ contains $list $keyword ]} {
                #item 808
                lappend result $keyword
            } else {
                
            }
            #item 8030003
            incr _ind803
            continue
        } else {
            break
        }
    }
    #item 1171
    if {$result == "const"} {
        
    } else {
        #item 805
        return $result
    }
}

proc find_not_belonging { list keywords } {
    #item 817
    set result {}
    #item 8190001
    set _col819 $list
    set _len819 [ llength $_col819 ]
    set _ind819 0
    while { 1 } {
        #item 8190002
        if {$_ind819 < $_len819} {
            #item 8190004
            set item [ lindex $_col819 $_ind819 ]
            #item 820
            if {[ contains $keywords $item ]} {
                
            } else {
                #item 823
                lappend result $item
            }
            #item 8190003
            incr _ind819
            continue
        } else {
            break
        }
    }
    #item 818
    return $result
}

proc generate { db gdb filename } {
    #item 964
    p.generate $db $gdb $filename "cpp"
}

proc generate_c { db gdb filename } {
    #item 977
    p.generate $db $gdb $filename "c"
}

proc get_property { line key } {
    #item 870
    set eq_position [ string first "=" $line ]
    #item 872
    if {$eq_position == -1} {
        #item 875
        return ""
    } else {
        #item 871
        set name [ string range $line 0 $eq_position-1 ]
        set value [ string range $line $eq_position+1 end ]
        set name [ string trim $name ]
        set value [ string trim $value ]
        #item 874
        if {$name == $key} {
            #item 873
            return $value
        } else {
            #item 875
            return ""
        }
    }
}

proc make_callbacks { language } {
    #item 1192
    set callbacks {}
    #item 1194
    gen::put_callback callbacks assign			gen_c::assign
    gen::put_callback callbacks compare			gen_c::compare
    gen::put_callback callbacks compare2		gen_c::compare
    gen::put_callback callbacks bad_case		gen_c::bad_case
    
    
    gen::put_callback callbacks body			gen_c::generate_body
    gen::put_callback callbacks signature		gen_cpp::extract_signature
    gen::put_callback callbacks and				gen_c::p.and
    gen::put_callback callbacks or				gen_c::p.or
    gen::put_callback callbacks not				gen_c::p.not
    gen::put_callback callbacks declare				gen_c::declare
    #item 1199
    if {$language == "c"} {
        #item 1197
        gen::put_callback callbacks comment gen_c::commentator
    } else {
        #item 1198
        gen::put_callback callbacks comment gen_cpp::commentator
    }
    #item 1193
    return $callbacks
}

proc noncopyable { fhandle class_name } {
    #item 1184
    puts $fhandle "private:"
    puts $fhandle "    // non-copyable"
    puts $fhandle "    $class_name\(const $class_name& other\) \{\}"
    puts $fhandle "    void operator=\(const $class_name& other\) \{\}"
}

proc p.generate { db gdb filename language } {
    #item 933
    set callbacks [ make_callbacks $language ]
    #item 922
    gen::fix_graph $gdb $callbacks 1
    #item 923
    set sections { 
    h_header h_footer c_header c_footer class options
    }
    unpack [ gen::scan_file_description $db $sections ] \
    h_header h_footer c_header c_footer class options
    #item 905
    set functions [ gen::generate_functions $db $gdb  \
    	$callbacks 0 ]
    #item 895
    if {[ graph::errors_occured ]} {
        
    } else {
        #item 937
        if {$language == "cpp"} {
            #item 938
            set copying [ extract_copying $options ]
            set class_name [ extract_class_name $class ]
        } else {
            #item 957
            set copying 0
            set class_name ""
        }
        #item 960
        unpack [ sort_functions $functions $language $class_name ] \
        free_funs \
        ctrs dtrs methods signals slots
        #item 928
        set h_filename [ replace_extension $filename "h" ]
        set c_filename [ replace_extension $filename $language ]
        set filenames [ list $h_filename $c_filename ]
        #item 929
        unpack [ open_files $filenames "w" ] hfile cfile
        #item 930
        catch {
            print_header $h_filename $hfile $free_funs \
            $ctrs $dtrs $methods $signals $slots \
            $h_header $h_footer $class $copying $class_name \
            $language
            
            print_cpp $h_filename $cfile $free_funs \
            $ctrs $dtrs $methods $slots \
            $c_header $c_footer $class_name \
            $language
        } error_message
        #item 931
        close_files [ list $hfile $cfile ]
        #item 896
        if {$error_message == ""} {
            
        } else {
            #item 897
            puts $::errorInfo
            error $error_message
        }
    }
}

proc print_cpp { header_filename fhandle functions ctrs dtrs methods slots header footer class_name language } {
    #item 204
    put_credits $fhandle
    #item 205
    set header_tail [ file tail $header_filename ]
    puts $fhandle "#include \"$header_tail\""
    #item 206
    puts $fhandle ""
    puts $fhandle $header
    #item 11440001
    set _col1144 [ filter_functions $functions 0 static ]
    set _len1144 [ llength $_col1144 ]
    set _ind1144 0
    while { 1 } {
        #item 11440002
        if {$_ind1144 < $_len1144} {
            #item 11440004
            set function [ lindex $_col1144 $_ind1144 ]
            #item 1146
            print_function $fhandle $function 1 "" $language
            #item 11440003
            incr _ind1144
            continue
        } else {
            break
        }
    }
    #item 11470001
    set _col1147 [ filter_functions $functions 1 static ]
    set _len1147 [ llength $_col1147 ]
    set _ind1147 0
    while { 1 } {
        #item 11470002
        if {$_ind1147 < $_len1147} {
            #item 11470004
            set function [ lindex $_col1147 $_ind1147 ]
            #item 1149
            print_function $fhandle $function 1 "" $language
            #item 11470003
            incr _ind1147
            continue
        } else {
            break
        }
    }
    #item 11500001
    set _col1150 [ filter_functions $functions 1 static ]
    set _len1150 [ llength $_col1150 ]
    set _ind1150 0
    while { 1 } {
        #item 11500002
        if {$_ind1150 < $_len1150} {
            #item 11500004
            set function [ lindex $_col1150 $_ind1150 ]
            #item 1152
            print_function $fhandle $function 0 "" $language
            #item 11500003
            incr _ind1150
            continue
        } else {
            break
        }
    }
    #item 11680001
    set _col1168 [ filter_functions $functions 0 static ]
    set _len1168 [ llength $_col1168 ]
    set _ind1168 0
    while { 1 } {
        #item 11680002
        if {$_ind1168 < $_len1168} {
            #item 11680004
            set function [ lindex $_col1168 $_ind1168 ]
            #item 1170
            print_function $fhandle $function 0 "" $language
            #item 11680003
            incr _ind1168
            continue
        } else {
            break
        }
    }
    #item 11530001
    set _col1153 [ filter_functions $functions 0 public ]
    set _len1153 [ llength $_col1153 ]
    set _ind1153 0
    while { 1 } {
        #item 11530002
        if {$_ind1153 < $_len1153} {
            #item 11530004
            set function [ lindex $_col1153 $_ind1153 ]
            #item 1155
            print_function $fhandle $function 0 "" $language
            #item 11530003
            incr _ind1153
            continue
        } else {
            break
        }
    }
    #item 11590001
    set _col1159 $ctrs
    set _len1159 [ llength $_col1159 ]
    set _ind1159 0
    while { 1 } {
        #item 11590002
        if {$_ind1159 < $_len1159} {
            #item 11590004
            set method [ lindex $_col1159 $_ind1159 ]
            #item 1161
            print_function $fhandle $method 0 $class_name "cpp"
            #item 11590003
            incr _ind1159
            continue
        } else {
            break
        }
    }
    #item 11620001
    set _col1162 $dtrs
    set _len1162 [ llength $_col1162 ]
    set _ind1162 0
    while { 1 } {
        #item 11620002
        if {$_ind1162 < $_len1162} {
            #item 11620004
            set method [ lindex $_col1162 $_ind1162 ]
            #item 1164
            print_function $fhandle $method 0 $class_name  "cpp"
            #item 11620003
            incr _ind1162
            continue
        } else {
            break
        }
    }
    #item 11650001
    set _col1165 $methods
    set _len1165 [ llength $_col1165 ]
    set _ind1165 0
    while { 1 } {
        #item 11650002
        if {$_ind1165 < $_len1165} {
            #item 11650004
            set method [ lindex $_col1165 $_ind1165 ]
            #item 1167
            print_function $fhandle $method 0 $class_name "cpp"
            #item 11650003
            incr _ind1165
            continue
        } else {
            break
        }
    }
    #item 12520001
    set _col1252 $slots
    set _len1252 [ llength $_col1252 ]
    set _ind1252 0
    while { 1 } {
        #item 12520002
        if {$_ind1252 < $_len1252} {
            #item 12520004
            set method [ lindex $_col1252 $_ind1252 ]
            #item 1254
            print_function $fhandle $method 0 $class_name "cpp"
            #item 12520003
            incr _ind1252
            continue
        } else {
            break
        }
    }
    #item 210
    puts $fhandle $footer
    #item 211
    puts $fhandle ""
}

proc print_function { fhandle function in_header class_name language } {
    #item 1035
    unpack $function diagram_id name signature body
    unpack $signature type prop_list parameters returns
    array set props $prop_list
    set inline $props(inline)
    #item 1174
    if {$language == "c"} {
        #item 1177
        set empty "void"
    } else {
        #item 1178
        set empty ""
    }
    #item 1063
    if {$type == "function"} {
        #item 1037
        set depth 0
        set static [ expr { $props(access) != "public" } ]
        set virtual 0
        set class ""
        set const 0
        set abstract 0
        set print_body [ expr !$in_header ]
        #item 1038
        print_function_kernel \
        $fhandle \
        $depth \
        $static \
        $virtual \
        $inline \
        $returns \
        $class \
        $name \
        $parameters \
        $props(const) \
        $abstract \
        $body \
        $print_body \
        $empty
    } else {
        #item 1046
        if {$in_header} {
            #item 1048
            set depth 1
            set static [ expr { $props(dispatch) == "static" } ]
            set virtual [ expr { $props(dispatch) == "virtual" } ]
            set class ""
            set abstract $props(abstract)
            #item 1051
            if {$inline} {
                #item 1054
                set print_body 1
            } else {
                #item 1050
                set print_body 0
            }
            #item 1059
            if {$type == "ctr"} {
                #item 1060
                set returns "explicit"
                set name $class_name
            } else {
                
            }
            #item 1068
            if {$type == "dtr"} {
                #item 1071
                set returns ""
                set name "~$class_name"
            } else {
                
            }
            #item 1038
            print_function_kernel \
            $fhandle \
            $depth \
            $static \
            $virtual \
            $inline \
            $returns \
            $class \
            $name \
            $parameters \
            $props(const) \
            $abstract \
            $body \
            $print_body \
            $empty
        } else {
            #item 1055
            set depth 0
            set static 0
            set virtual 0
            set class $class_name
            set abstract 0
            #item 1056
            if {($inline) || ($props(abstract))} {
                
            } else {
                #item 1070
                set print_body 1
                #item 1064
                if {$type == "ctr"} {
                    #item 1065
                    set returns ""
                    set name $class_name
                } else {
                    
                }
                #item 1068
                if {$type == "dtr"} {
                    #item 1071
                    set returns ""
                    set name "~$class_name"
                } else {
                    
                }
                #item 1038
                print_function_kernel \
                $fhandle \
                $depth \
                $static \
                $virtual \
                $inline \
                $returns \
                $class \
                $name \
                $parameters \
                $props(const) \
                $abstract \
                $body \
                $print_body \
                $empty
            }
        }
    }
}

proc print_function_kernel { fhandle depth static virtual inline returns class name parameters const abstract body print_body empty } {
    #item 515
    set result {}
    set line ""
    #item 513
    if {$static} {
        #item 514
        append line "static "
    } else {
        
    }
    #item 518
    if {$virtual} {
        #item 519
        append line "virtual "
    } else {
        
    }
    #item 522
    if {$inline} {
        #item 523
        append line "inline "
    } else {
        
    }
    #item 526
    append line "$returns "
    #item 533
    if {$class == ""} {
        
    } else {
        #item 535
        append line "$class\:\:"
    }
    #item 536
    append line "$name\("
    #item 588
    set param_count [ llength $parameters ]
    #item 527
    if {$param_count == 0} {
        #item 537
        append line "$empty\)"
    } else {
        #item 550
        lappend result $line
        #item 5400001
        set i 0
        while { 1 } {
            #item 5400002
            if {$i < $param_count} {
                #item 543
                set parameter_info [ lindex $parameters $i ]
                set parameter [ lindex $parameter_info 0 ]
                #item 541
                set line "    $parameter"
                #item 544
                if {$i == $param_count - 1} {
                    
                } else {
                    #item 545
                    append line ","
                }
                #item 552
                lappend result $line
                #item 5400003
                incr i
                continue
            } else {
                break
            }
        }
        #item 542
        set line "\)"
    }
    #item 560
    if {$const} {
        #item 561
        append line " const"
    } else {
        
    }
    #item 564
    if {$abstract} {
        #item 565
        append line " = 0"
    } else {
        
    }
    #item 568
    if {$print_body} {
        #item 571
        append line " \{"
        #item 572
        lappend result $line
        #item 5830001
        set _col583 $body
        set _len583 [ llength $_col583 ]
        set _ind583 0
        while { 1 } {
            #item 5830002
            if {$_ind583 < $_len583} {
                #item 5830004
                set line [ lindex $_col583 $_ind583 ]
                #item 582
                lappend result "    $line"
                #item 5830003
                incr _ind583
                continue
            } else {
                break
            }
        }
        #item 585
        lappend result "\}"
    } else {
        #item 570
        append line ";"
        #item 573
        lappend result $line
    }
    #item 1021
    set space [ gen::make_indent $depth ]
    #item 10200001
    set _col1020 $result
    set _len1020 [ llength $_col1020 ]
    set _ind1020 0
    while { 1 } {
        #item 10200002
        if {$_ind1020 < $_len1020} {
            #item 10200004
            set line [ lindex $_col1020 $_ind1020 ]
            #item 1022
            puts -nonewline $fhandle $space
            puts $fhandle $line
            #item 10200003
            incr _ind1020
            continue
        } else {
            break
        }
    }
    #item 1023
    puts $fhandle ""
}

proc print_header { filename fhandle functions ctrs dtrs methods signals slots header footer class copying class_name language } {
    #item 181
    put_credits $fhandle
    #item 171
    set guard [ gen_c::guard_name $filename ]
    #item 182
    puts $fhandle "#ifndef $guard"
    puts $fhandle "#define $guard"
    #item 183
    puts $fhandle ""
    puts $fhandle $header
    #item 1840001
    set _col184 [ filter_functions $functions 0 public ]
    set _len184 [ llength $_col184 ]
    set _ind184 0
    while { 1 } {
        #item 1840002
        if {$_ind184 < $_len184} {
            #item 1840004
            set function [ lindex $_col184 $_ind184 ]
            #item 186
            print_function $fhandle $function 1 "" $language
            #item 1840003
            incr _ind184
            continue
        } else {
            break
        }
    }
    #item 11070001
    set _col1107 [ filter_functions $functions 1 public ]
    set _len1107 [ llength $_col1107 ]
    set _ind1107 0
    while { 1 } {
        #item 11070002
        if {$_ind1107 < $_len1107} {
            #item 11070004
            set function [ lindex $_col1107 $_ind1107 ]
            #item 1109
            print_function $fhandle $function 1 "" $language
            #item 11070003
            incr _ind1107
            continue
        } else {
            break
        }
    }
    #item 11100001
    set _col1110 [ filter_functions $functions 1 public ]
    set _len1110 [ llength $_col1110 ]
    set _ind1110 0
    while { 1 } {
        #item 11100002
        if {$_ind1110 < $_len1110} {
            #item 11100004
            set function [ lindex $_col1110 $_ind1110 ]
            #item 1112
            print_function $fhandle $function 0 "" $language
            #item 11100003
            incr _ind1110
            continue
        } else {
            break
        }
    }
    #item 1025
    if {$class == ""} {
        
    } else {
        #item 1131
        puts $fhandle $class
        #item 1185
        if {$copying} {
            
        } else {
            #item 1186
            noncopyable $fhandle $class_name
        }
        #item 1132
        print_methods $fhandle $ctrs public $class_name
        #item 1133
        print_methods $fhandle $ctrs protected $class_name
        #item 1135
        print_methods $fhandle $dtrs public $class_name
        #item 1134
        print_methods $fhandle $ctrs private $class_name
        #item 1255
        print_methods $fhandle $signals public $class_name "signals"
        #item 1245
        print_methods $fhandle $slots public $class_name "public slots"
        #item 1246
        print_methods $fhandle $slots protected $class_name "protected slots"
        #item 1247
        print_methods $fhandle $slots private $class_name "private slots"
        #item 1138
        print_methods $fhandle $methods public $class_name
        #item 1139
        print_methods $fhandle $methods protected $class_name
        #item 1140
        print_methods $fhandle $methods private $class_name
        #item 1024
        puts $fhandle "\};"
    }
    #item 187
    puts $fhandle $footer
    #item 188
    puts $fhandle "#endif"
    puts $fhandle ""
}

proc print_methods { fhandle functions access class_name {access_label ""} } {
    #item 1118
    set to_print [ filter_methods $functions $access ]
    #item 1119
    if {$to_print == ""} {
        
    } else {
        #item 1248
        if {$access_label == ""} {
            #item 1251
            set access_label $access
        } else {
            
        }
        #item 1120
        puts $fhandle "$access_label:"
        #item 11210001
        set _col1121 $to_print
        set _len1121 [ llength $_col1121 ]
        set _ind1121 0
        while { 1 } {
            #item 11210002
            if {$_ind1121 < $_len1121} {
                #item 11210004
                set method [ lindex $_col1121 $_ind1121 ]
                #item 1124
                print_function $fhandle $method 1 $class_name "cpp"
                #item 11210003
                incr _ind1121
                continue
            } else {
                break
            }
        }
    }
}

proc put_credits { fhandle } {
    #item 180
    set version [ version_string ]
    puts $fhandle \
        "/* Autogenerated with DRAKON Editor $version */"
}

proc sort_functions { functions language class_name } {
    #item 968
    set free_funs {}
    set ctrs {}
    set dtrs {}
    set methods {}
    set signals {}
    set slots {}
    #item 9790001
    set _col979 $functions
    set _len979 [ llength $_col979 ]
    set _ind979 0
    while { 1 } {
        #item 9790002
        if {$_ind979 < $_len979} {
            #item 9790004
            set function [ lindex $_col979 $_ind979 ]
            #item 978
            unpack $function diagram_id name signature body
            unpack $signature type prop_list
            array set props $prop_list
            #item 980
            if {$type == "comment"} {
                
            } else {
                #item 983
                if {$type == "function"} {
                    
                } else {
                    #item 981
                    if {$language == "c"} {
                        #item 986
                        error \
                        "$name: methods, constructors and destructors not supported by C language."
                        #item 988
                        error \
                        "$name: cannot have methods: class not defined."
                    } else {
                        #item 987
                        if {$class_name == ""} {
                            #item 988
                            error \
                            "$name: cannot have methods: class not defined."
                        } else {
                            
                        }
                    }
                }
                #item 9890001
                if {$type == "function"} {
                    #item 999
                    lappend free_funs $function
                } else {
                    #item 9890002
                    if {$type == "signal"} {
                        #item 1240
                        lappend signals $function
                    } else {
                        #item 9890003
                        if {$type == "slot"} {
                            #item 1243
                            lappend slots $function
                        } else {
                            #item 9890004
                            if {$type == "method"} {
                                #item 1009
                                lappend methods $function
                            } else {
                                #item 9890005
                                if {$type == "ctr"} {
                                    #item 1012
                                    lappend ctrs $function
                                } else {
                                    #item 9890006
                                    if {$type == "dtr"} {
                                        
                                    } else {
                                        #item 9890007
                                        error "Unexpected switch value: $type"
                                    }
                                    #item 1013
                                    lappend dtrs $function
                                }
                            }
                        }
                    }
                }
            }
            #item 9790003
            incr _ind979
            continue
        } else {
            break
        }
    }
    #item 971
    return [ list \
    $free_funs \
    $ctrs \
    $dtrs \
    $methods \
    $signals \
    $slots ]
}

}
