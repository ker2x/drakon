namespace eval cbody {

variable assign ""
variable compare ""
variable while_start ""
variable if_start ""
variable elseif_start ""
variable if_end ""
variable else_start ""
variable pass ""
variable cont ""
variable return_none ""
variable block_close ""
variable comment ""
variable bad_case ""
# Autogenerated with DRAKON Editor 1.10

proc generate_body { gdb diagram_id start_item node_list items incoming callbacks } {
    #item 76
    save_callbacks $callbacks
    #item 206
    variable comment
    variable block_close
    variable while_start
    variable assign
    set declare [ gen::get_callback $callbacks declare ]
    #item 12
    set result {}
    set count [ llength $items ]
    #item 16
    if {$count == 0} {
        #item 243
        set base 0
    } else {
        #item 27
        array set nodes $node_list
        array set incoming_map $incoming
        set i 0
        set skip_if 0
        #item 20
        if {$count == 1} {
            #item 240
            if {$incoming_map($start_item) == 0} {
                #item 24
                set base 0
            } else {
                #item 23
                set base 2
                #item 25
                lappend result [ $declare "int" "_next_item_" "0" ]
                lappend result [ $assign _next_item_ $start_item ]
                lappend result [ $while_start ]
            }
        } else {
            #item 246
            if {$incoming_map($start_item) == 0} {
                #item 256
                set start_node $nodes($start_item)
                #item 257
                if {[ is_init_node $start_node ]} {
                    #item 274
                    unpack [ get_node_text_next $start_node ] text start_item
                    #item 248
                    incr i
                    gen::add_lines result "" $text "" 0 0
                } else {
                    
                }
            } else {
                
            }
            #item 23
            set base 2
            #item 25
            lappend result [ $declare "int" "_next_item_" "0" ]
            lappend result [ $assign _next_item_ $start_item ]
            lappend result [ $while_start ]
        }
        while { 1 } {
            #item 28
            set item_id [ lindex $items $i ]
            set node $nodes($item_id)	
            unpack $node body links
            unpack $body type text b
            #item 45
            set next_i [ expr { $i + 1 } ]
            #item 44
            if {$next_i < $count} {
                #item 46
                set next_item_id [ lindex $items $next_i ]
                set next_incoming $incoming_map($next_item_id)
                #item 47
                if {($next_incoming == 1) && ([ p.one_exit $links $next_item_id ])} {
                    
                } else {
                    #item 48
                    set next_item_id ""
                }
            } else {
                #item 48
                set next_item_id ""
            }
            #item 51
            if {($skip_if) || (!($base == 2))} {
                #item 52
                gen::add_line result [ $comment "item $item_id" ] 0 1
            } else {
                #item 30
                p.if result _next_item_ $item_id 1
            }
            #item 320001
            if {$type == "if"} {
                #item 37
                p.generate_if \
                result $links $text $b $base \
                $next_item_id $items $i
            } else {
                #item 320002
                if {$type == "select"} {
                    #item 38
                    p.generate_select \
                    result $item_id $links $text $base \
                    $next_item_id $items $i
                } else {
                    #item 66
                    p.generate_action \
                    result $links $text $base \
                    $next_item_id $items $i
                }
            }
            #item 54
            if {$next_item_id == ""} {
                #item 244
                if {$base == 2} {
                    #item 234
                    $block_close result 1
                } else {
                    
                }
                #item 53
                set skip_if 0
            } else {
                #item 55
                set skip_if 1
            }
            #item 68
            lappend result ""
            #item 58
            incr i
            #item 59
            if {$i < $count} {
                continue
            } else {
                break
            }
        }
    }
    #item 230
    if {$base == 2} {
        #item 231
        $block_close result 0
    } else {
        
    }
    #item 17
    return $result
}

proc get_node_text_next { node } {
    #item 254
    unpack $node body links
    unpack $body type text b
    #item 270
    if {[ llength $links ] == 0} {
        #item 273
        set next ""
    } else {
        #item 269
        set link0 [ lindex $links 0 ]
        set next [ lindex $link0 0 ]
    }
    #item 255
    return [ list $text $next ]
}

proc is_init_node { node } {
    #item 263
    unpack $node body links
    unpack $body type text b
    #item 265
    if {$type == "action"} {
        #item 264
        return 1
    } else {
        #item 268
        return 0
    }
}

proc p.add_block { output text base jump_item next_item_id items i } {
    #item 175
    upvar 1 $output result
    #item 169
    if {$text == ""} {
        #item 174
        set has_text 0
    } else {
        #item 170
        gen::add_lines result "" $text "" $base 1
        set has_text 1
    }
    #item 173
    p.jump result $jump_item $base 1 $next_item_id $has_text $items $i
}

proc p.elif { output variable constant depth } {
    #item 226
    upvar 1 $output result
    #item 225
    variable elseif_start
    variable if_end
    variable compare
    #item 227
    gen::add_line result \
    "[ $elseif_start ][ $compare $variable $constant ][ $if_end ]" \
    $depth 0
}

proc p.generate_action { output links text base next_item_id items i } {
    #item 181
    upvar 1 $output result
    #item 183
    incr base -1
    #item 184
    set link [ lindex $links 0 ]
    set dst_item [ lindex $link 0 ]
    #item 182
    p.add_block result $text $base $dst_item $next_item_id $items $i
}

proc p.generate_if { output links text b base next_item_id items i } {
    #item 215
    variable if_start
    variable if_end
    variable else_start
    variable block_close
    #item 126
    upvar 1 $output result
    #item 120
    set then_index 1
    set else_index 0
    #item 123
    unpack [ lindex $links $then_index ] then_item foo then_code
    unpack [ lindex $links $else_index ] else_item foo else_code
    #item 124
    gen::add_lines result \
    [ $if_start ] $text [ $if_end ] $base 0
    #item 127
    p.add_block result $then_code $base $then_item $next_item_id $items $i
    #item 125
    gen::add_line result [ $else_start ] $base 0
    #item 128
    p.add_block result $else_code $base $else_item $next_item_id $items $i
    #item 218
    $block_close result $base
}

proc p.generate_select { output item_id links text base next_item_id items j } {
    #item 216
    variable if_start
    variable elseif_start
    variable if_end
    variable else_start
    variable block_close
    variable bad_case
    variable assign
    #item 161
    upvar 1 $output result
    #item 162
    set has_text [ llength $text ]
    #item 143
    set switch_var "_sw_$item_id"
    set value [ join $text "\n" ]
    gen::add_line result [ $assign $switch_var $value ] $base 0
    #item 145
    set has_default 0
    set count [ llength $links ]
    #item 1470001
    set i 0
    while { 1 } {
        #item 1470002
        if {$i < $count} {
            #item 148
            set link [ lindex $links $i ]
            unpack $link dst_item branch_value branch_code
            #item 149
            if {$i == 0} {
                #item 144
                p.if result $switch_var $branch_value $base
            } else {
                #item 150
                if {$branch_value == ""} {
                    #item 151
                    set has_default 1
                    gen::add_line result [ $else_start ] $base 0
                } else {
                    #item 152
                    p.elif result $switch_var $branch_value $base
                }
            }
            #item 163
            p.add_block result $branch_code $base $dst_item $next_item_id $items $j
            #item 1470003
            incr i
            continue
        } else {
            break
        }
    }
    #item 156
    if {$has_default} {
        
    } else {
        #item 157
        gen::add_line result [ $else_start ] $base 0
        gen::add_line result [ $bad_case $switch_var ] $base 1
    }
    #item 228
    $block_close result $base
    #item 160
    return $result
}

proc p.if { output variable constant depth } {
    #item 213
    upvar 1 $output result
    #item 212
    variable if_start
    variable if_end
    variable compare
    #item 214
    gen::add_line result \
    "[ $if_start ][ $compare $variable $constant ][ $if_end ]" \
    $depth 0
}

proc p.jump { output item_id base depth next_item_id has_text items i } {
    #item 93
    upvar 1 $output result
    #item 229
    variable return_none
    variable pass
    variable cont
    variable assign
    #item 101
    set next_ordinal [ lsearch $items $item_id ]
    #item 820001
    if {$item_id == "last_item"} {
        #item 90
        gen::add_line result \
        [ $return_none ] $base $depth
    } else {
        #item 820002
        if {$item_id == $next_item_id} {
            #item 94
            if {$has_text} {
                
            } else {
                #item 104
                gen::add_line result \
                [ $pass ] $base $depth
            }
        } else {
            #item 820003
            if {$item_id == "has_return"} {
                
            } else {
                #item 105
                gen::add_line result \
                [ $assign _next_item_ $item_id ] $base $depth
                #item 102
                if {$next_ordinal <= $i} {
                    #item 106
                    gen::add_line result \
                    [ $cont ] $base $depth
                } else {
                    
                }
            }
        }
    }
}

proc p.one_exit { links item_id } {
    #item 1910001
    set _col191 $links
    set _len191 [ llength $_col191 ]
    set _ind191 0
    while { 1 } {
        #item 1910002
        if {$_ind191 < $_len191} {
            #item 1910004
            set link [ lindex $_col191 $_ind191 ]
            #item 190
            set linked_item [ lindex $link 0 ]
            #item 238
            set found 0
            #item 1930001
            if {$linked_item == $item_id} {
                #item 239
                set found 1
                #item 1910003
                incr _ind191
                continue
            } else {
                #item 1930002
                if {($linked_item == "last_item") || ($linked_item == "has_return")} {
                    #item 1910003
                    incr _ind191
                    continue
                } else {
                    #item 205
                    return 0
                }
            }
        } else {
            #item 204
            return $found
        }
    }
}

proc save_callbacks { callbacks } {
    #item 75
    variable assign
    variable compare
    variable while_start
    variable if_start
    variable elseif_start
    variable if_end
    variable else_start
    variable pass
    variable cont
    variable return_none
    variable block_close
    variable comment
    variable bad_case
    #item 73
    set assign [ gen::get_callback $callbacks assign ]
    set compare [ gen::get_callback $callbacks compare ]
    set while_start [ gen::get_callback $callbacks while_start ]
    set if_start [ gen::get_callback $callbacks if_start ]
    set elseif_start [ gen::get_callback $callbacks elseif_start ]
    set if_end [ gen::get_callback $callbacks if_end ]
    set else_start [ gen::get_callback $callbacks else_start ]
    set pass [ gen::get_callback $callbacks pass ]
    set cont [ gen::get_callback $callbacks continue ]
    set return_none [ gen::get_callback $callbacks return_none ]
    set block_close [ gen::get_callback $callbacks block_close ]
    set comment [ gen::get_callback $callbacks comment ]
    set bad_case [ gen::get_callback $callbacks bad_case ]
}

}
