#gen::add_generator "C" gen_c::generate

namespace eval gen_c {

# Autogenerated with DRAKON Editor 1.10

proc assign { variable value } {
    #item 578
    return "$variable = $value;"
}

proc bad_case { switch_var } {
    #item 588
    return "UnexpectedBranch\($switch_var\);"
}

proc commentator { text } {
    #item 143
    return "/* $text */"
}

proc compare { variable constant } {
    #item 584
    return "$variable == $constant"
}

proc contains_exit { links item_id } {
    #item 5330001
    set _col533 $links
    set _len533 [ llength $_col533 ]
    set _ind533 0
    while { 1 } {
        #item 5330002
        if {$_ind533 < $_len533} {
            #item 5330004
            set link [ lindex $_col533 $_ind533 ]
            #item 532
            set linked_item [ lindex $link 0 ]
            #item 550
            if {$linked_item == $item_id} {
                #item 548
                return 1
            } else {
                #item 5330003
                incr _ind533
                continue
            }
        } else {
            #item 546
            return 0
        }
    }
}

proc declare { type name value } {
    #item 616
    return "$type $name = $value;"
}

proc extract_return_type { text } {
    #item 491
    set skip [ string length "returns " ]
    set raw [ string range $text $skip end ]
    return [ string trim $raw ]
}

proc extract_signature { text name } {
    #item 41
    set error_message ""
    set type function
    set access static
    set returns void
    set parameters {}
    #item 15
    set lines [ gen::separate_from_comments $text ]
    #item 17
    if {[ llength $lines ] == 0} {
        
    } else {
        #item 16
        set first_line [ lindex $lines 0 ]
        set first [ lindex $first_line 0 ]
        #item 200001
        if {$first == "#comment"} {
            #item 42
            set type comment
        } else {
            #item 200002
            if {$first == "public"} {
                #item 30
                set access public
                set start 1
            } else {
                #item 31
                set start 0
            }
            #item 34
            set count [ llength $lines ]
            set last [ expr { $count - 1 } ]
            #item 370001
            set i $start
            while { 1 } {
                #item 370002
                if {$i < $count} {
                    #item 36
                    set current [ lindex $lines $i ]
                    set stripped [ lindex $current 0 ]
                    #item 46
                    if {[ string match "returns*" $stripped ]} {
                        #item 47
                        if {$i == $last} {
                            #item 50
                            set returns [ extract_return_type $stripped ]
                            #item 370003
                            incr i
                            continue
                        } else {
                            #item 52
                            set error_message \
                            "'returns' can only be the last line."
                            break
                        }
                    } else {
                        #item 45
                        lappend parameters $current
                        #item 370003
                        incr i
                        continue
                    }
                } else {
                    break
                }
            }
        }
    }
    #item 492
    if {$returns == ""} {
        #item 493
        set error_message "Empty return value."
    } else {
        
    }
    #item 38
    return [ list $error_message \
    [ gen::create_signature $type $access $parameters $returns ] ]
}

proc generate { db gdb filename } {
    #item 610
    set callbacks [ make_callbacks ]
    #item 146
    gen::fix_graph $gdb $callbacks 1
    #item 147
    set sections { h_header h_footer c_header c_footer }
    unpack [ gen::scan_file_description $db $sections ] \
    h_header h_footer c_header c_footer
    #item 71
    set functions [ gen::generate_functions $db $gdb  \
    	$callbacks 0 ]
    #item 60
    if {[ graph::errors_occured ]} {
        
    } else {
        #item 80
        set public {}
        set static {}
        #item 820001
        set _col82 $functions
        set _len82 [ llength $_col82 ]
        set _ind82 0
        while { 1 } {
            #item 820002
            if {$_ind82 < $_len82} {
                #item 820004
                set function [ lindex $_col82 $_ind82 ]
                #item 83
                set signature [ lindex $function 2 ]
                set type [ lindex $signature 0 ]
                set access [ lindex $signature 1 ]
                #item 148
                if {$type == "comment"} {
                    
                } else {
                    #item 150
                    if {$access == "public"} {
                        #item 84
                        lappend public $function
                    } else {
                        #item 149
                        lappend static $function
                    }
                }
                #item 820003
                incr _ind82
                continue
            } else {
                break
            }
        }
        #item 152
        set h_filename [ replace_extension $filename "h" ]
        set c_filename [ replace_extension $filename "c" ]
        set filenames [ list $h_filename $c_filename ]
        #item 153
        unpack [ open_files $filenames "w" ] hfile cfile
        #item 154
        catch {
            print_header $h_filename $hfile $public $h_header $h_footer
            print_c $h_filename $cfile $public $static $c_header $c_footer
        } error_message
        #item 155
        close_files [ list $hfile $cfile ]
        #item 62
        if {$error_message == ""} {
            
        } else {
            #item 63
            puts $::errorInfo
            error $error_message
        }
    }
}

proc generate_body { gdb diagram_id start_item node_list items incoming } {
    #item 275
    set result {}
    set count [ llength $items ]
    #item 552
    print_switches result $node_list
    #item 290
    array set nodes $node_list
    array set incoming_map $incoming
    set i 0
    set base 0
    #item 515
    if {$count == 0} {
        
    } else {
        #item 517
        set first_item [ lindex $items 0 ]
        set first_incoming $incoming_map($first_item)
        #item 518
        if {$first_incoming == 0} {
            #item 516
            set skip_label 1
        } else {
            #item 519
            set skip_label 0
        }
        while { 1 } {
            #item 291
            set item_id [ lindex $items $i ]
            set node $nodes($item_id)	
            unpack $node body links
            unpack $body type text b
            #item 308
            set next_i [ expr { $i + 1 } ]
            #item 307
            if {$next_i < $count} {
                #item 309
                set next_item_id [ lindex $items $next_i ]
                #item 522
                set next_item_id [ lindex $items $next_i ]
                set next_incoming $incoming_map($next_item_id)
                #item 523
                if {($next_incoming == 1) && ([ contains_exit $links $next_item_id ])} {
                    #item 525
                    set next_skip_label 1
                } else {
                    #item 526
                    set next_skip_label 0
                }
            } else {
                #item 311
                set next_item_id ""
                #item 526
                set next_skip_label 0
            }
            #item 314
            if {$skip_label} {
                #item 343
                set tag [ commentator "item $item_id" ]
            } else {
                #item 485
                set tag [ label_name $item_id ]
                append tag ":"
            }
            #item 342
            gen::add_line result $tag 0 0
            #item 2950001
            if {$type == "if"} {
                #item 300
                p.generate_if \
                result $links $text $b $base \
                $next_item_id $items $i
            } else {
                #item 2950002
                if {$type == "select"} {
                    #item 301
                    p.generate_select \
                    result $item_id $links $text $base \
                    $next_item_id $items $i
                } else {
                    #item 329
                    p.generate_action \
                    result $links $text $base \
                    $next_item_id $items $i
                }
            }
            #item 512
            set skip_label $next_skip_label
            #item 331
            lappend result ""
            #item 321
            incr i
            #item 322
            if {$i < $count} {
                continue
            } else {
                break
            }
        }
    }
    #item 280
    return $result
}

proc guard_name { filename } {
    #item 499
    set tail [ file tail $filename ]
    set no_dots [ string map { "." "_" } $tail ]
    set random [ expr { int(rand() * 100000) } ]
    append no_dots $random
    set guard [ string toupper $no_dots ]
    #item 502
    return $guard
}

proc label_name { item_id } {
    #item 478
    return "item_$item_id"
}

proc make_callbacks { } {
    #item 571
    set callbacks {}
    #item 591
    gen::put_callback callbacks assign			gen_c::assign
    gen::put_callback callbacks compare			gen_c::compare
    gen::put_callback callbacks compare2		gen_c::compare
    gen::put_callback callbacks bad_case		gen_c::bad_case
    gen::put_callback callbacks comment			gen_c::commentator
    
    gen::put_callback callbacks body			gen_c::generate_body
    gen::put_callback callbacks signature		gen_c::extract_signature
    gen::put_callback callbacks and				gen_c::p.and
    gen::put_callback callbacks or				gen_c::p.or
    gen::put_callback callbacks not				gen_c::p.not
    #item 572
    return $callbacks
}

proc p.add_block { output text base jump_item next_item_id items i } {
    #item 447
    upvar 1 $output result
    #item 441
    if {$text == ""} {
        #item 446
        set has_text 0
    } else {
        #item 442
        gen::add_lines result "" $text "" $base 1
        set has_text 1
    }
    #item 445
    p.jump result $jump_item $base 1 $next_item_id $has_text $items $i
}

proc p.and { left right } {
    #item 595
    return "($left) && ($right)"
}

proc p.elif { output variable constant depth } {
    #item 471
    upvar 1 $output result
    #item 472
    gen::add_line result \
    "\} else if \($variable == $constant\) \{" $depth 0
}

proc p.generate_action { output links text base next_item_id items i } {
    #item 453
    upvar 1 $output result
    #item 455
    incr base -1
    #item 456
    set link [ lindex $links 0 ]
    set dst_item [ lindex $link 0 ]
    #item 454
    p.add_block result $text $base $dst_item $next_item_id $items $i
}

proc p.generate_if { output links text b base next_item_id items i } {
    #item 394
    upvar 1 $output result
    #item 386
    if {$b == 1} {
        #item 387
        set then_index 0
        set else_index 1
    } else {
        #item 388
        set then_index 1
        set else_index 0
    }
    #item 391
    unpack [ lindex $links $then_index ] then_item foo then_code
    unpack [ lindex $links $else_index ] else_item foo else_code
    #item 392
    gen::add_lines result \
    "if \(" $text "\) \{" $base 0
    #item 395
    p.add_block result $then_code $base $then_item $next_item_id $items $i
    #item 393
    gen::add_line result "\} else \{" $base 0
    #item 396
    p.add_block result $else_code $base $else_item $next_item_id $items $i
    #item 398
    gen::add_line result "\}" $base 0
}

proc p.generate_select { output item_id links text base next_item_id items j } {
    #item 431
    upvar 1 $output result
    #item 413
    set switch_var [ switch_var $item_id ]
    set value [ join $text "\n" ]
    gen::add_line result "$switch_var = $value;" $base 0
    #item 415
    set has_default 0
    set count [ llength $links ]
    set base 0
    #item 4170001
    set i 0
    while { 1 } {
        #item 4170002
        if {$i < $count} {
            #item 418
            set link [ lindex $links $i ]
            unpack $link dst_item branch_value branch_code
            #item 419
            if {$i == 0} {
                #item 414
                p.if result $switch_var $branch_value $base
            } else {
                #item 420
                if {$branch_value == ""} {
                    #item 421
                    set has_default 1
                    gen::add_line result "\} else \{" $base 0
                } else {
                    #item 422
                    p.elif result $switch_var $branch_value $base
                }
            }
            #item 433
            p.add_block result $branch_code $base $dst_item $next_item_id $items $j
            #item 4170003
            incr i
            continue
        } else {
            break
        }
    }
    #item 426
    if {$has_default} {
        
    } else {
        #item 427
        gen::add_line result "\} else \{" $base 0
        gen::add_line result "UnexpectedBranch\($switch_var\);" $base 1
    }
    #item 435
    lappend result "\}"
    #item 430
    return $result
}

proc p.if { output variable constant depth } {
    #item 463
    upvar 1 $output result
    #item 464
    gen::add_line result \
    "if \($variable == $constant\) \{" $depth 0
}

proc p.jump { output item_id base depth next_item_id has_text items i } {
    #item 360
    upvar 1 $output result
    #item 368
    set next_ordinal [ lsearch $items $item_id ]
    #item 3490001
    if {$item_id == "last_item"} {
        #item 357
        gen::add_line result \
        "return;" $base $depth
    } else {
        #item 3490002
        if {($item_id == $next_item_id) || ($item_id == "has_return")} {
            
        } else {
            #item 372
            set label [ label_name $item_id ]
            gen::add_line result "goto $label;" $base $depth
        }
    }
}

proc p.not { operand } {
    #item 607
    return "!($operand)"
}

proc p.or { left right } {
    #item 603
    return "($left) || ($right)"
}

proc print_c { header_filename fhandle public static header footer } {
    #item 204
    put_credits $fhandle
    #item 205
    set header_tail [ file tail $header_filename ]
    puts $fhandle "#include \"$header_tail\""
    #item 206
    puts $fhandle ""
    puts $fhandle $header
    #item 2150001
    set _col215 $static
    set _len215 [ llength $_col215 ]
    set _ind215 0
    while { 1 } {
        #item 2150002
        if {$_ind215 < $_len215} {
            #item 2150004
            set function [ lindex $_col215 $_ind215 ]
            #item 217
            print_function $fhandle $function 1
            #item 2150003
            incr _ind215
            continue
        } else {
            break
        }
    }
    #item 2070001
    set _col207 $static
    set _len207 [ llength $_col207 ]
    set _ind207 0
    while { 1 } {
        #item 2070002
        if {$_ind207 < $_len207} {
            #item 2070004
            set function [ lindex $_col207 $_ind207 ]
            #item 209
            print_function $fhandle $function 0
            #item 2070003
            incr _ind207
            continue
        } else {
            break
        }
    }
    #item 2190001
    set _col219 $public
    set _len219 [ llength $_col219 ]
    set _ind219 0
    while { 1 } {
        #item 2190002
        if {$_ind219 < $_len219} {
            #item 2190004
            set function [ lindex $_col219 $_ind219 ]
            #item 221
            print_function $fhandle $function 0
            #item 2190003
            incr _ind219
            continue
        } else {
            break
        }
    }
    #item 210
    puts $fhandle $footer
    #item 211
    puts $fhandle ""
}

proc print_function { fhandle function declaration } {
    #item 229
    unpack $function diagram_id name signature body
    #item 228
    unpack $signature type access parameters returns
    set param_names {}
    #item 2360001
    set _col236 $parameters
    set _len236 [ llength $_col236 ]
    set _ind236 0
    while { 1 } {
        #item 2360002
        if {$_ind236 < $_len236} {
            #item 2360004
            set parameter [ lindex $_col236 $_ind236 ]
            #item 235
            set pname [ lindex $parameter 0 ]
            lappend param_names $pname
            #item 2360003
            incr _ind236
            continue
        } else {
            break
        }
    }
    #item 503
    set param_count [ llength $param_names ]
    #item 243
    puts -nonewline $fhandle "$returns $name\("
    #item 244
    if {$param_count == 0} {
        #item 246
        puts -nonewline $fhandle "void\)"
    } else {
        #item 249
        puts $fhandle ""
        #item 2480001
        set i 0
        while { 1 } {
            #item 2480002
            if {$i < $param_count} {
                #item 504
                set parameter [ lindex $param_names $i ]
                #item 250
                puts -nonewline $fhandle "    $parameter"
                #item 505
                if {$i == $param_count - 1} {
                    #item 507
                    puts $fhandle ""
                } else {
                    #item 506
                    puts $fhandle ","
                }
                #item 2480003
                incr i
                continue
            } else {
                break
            }
        }
        #item 251
        puts -nonewline $fhandle "\)"
    }
    #item 252
    if {$declaration} {
        #item 254
        puts $fhandle ";"
    } else {
        #item 253
        puts $fhandle " \{"
        #item 230
        set body_lines [ gen::indent $body 1 ]
        #item 231
        puts $fhandle $body_lines
        #item 260
        puts $fhandle "\}"
    }
    #item 259
    puts $fhandle ""
}

proc print_header { filename fhandle functions header footer } {
    #item 181
    put_credits $fhandle
    #item 171
    set guard [ guard_name $filename ]
    #item 182
    puts $fhandle "#ifndef $guard"
    puts $fhandle "#define $guard"
    #item 183
    puts $fhandle ""
    puts $fhandle $header
    #item 1840001
    set _col184 $functions
    set _len184 [ llength $_col184 ]
    set _ind184 0
    while { 1 } {
        #item 1840002
        if {$_ind184 < $_len184} {
            #item 1840004
            set function [ lindex $_col184 $_ind184 ]
            #item 186
            print_function $fhandle $function 1
            #item 1840003
            incr _ind184
            continue
        } else {
            break
        }
    }
    #item 187
    puts $fhandle $footer
    #item 188
    puts $fhandle "#endif"
    puts $fhandle ""
}

proc print_switches { output node_list } {
    #item 558
    upvar 1 $output result
    array set nodes $node_list
    #item 5590001
    set _col559 [ array names nodes ]
    set _len559 [ llength $_col559 ]
    set _ind559 0
    while { 1 } {
        #item 5590002
        if {$_ind559 < $_len559} {
            #item 5590004
            set item_id [ lindex $_col559 $_ind559 ]
            #item 561
            set node $nodes($item_id)	
            unpack $node body links
            unpack $body type text b
            #item 562
            if {$type == "select"} {
                #item 565
                set var [ switch_var $item_id ]
                lappend result "int $var;"
            } else {
                
            }
            #item 5590003
            incr _ind559
            continue
        } else {
            break
        }
    }
}

proc put_credits { fhandle } {
    #item 180
    set version [ version_string ]
    puts $fhandle \
        "/* Autogenerated with DRAKON Editor $version */"
}

proc switch_var { item_id } {
    #item 483
    return "_sw_$item_id"
}

}
